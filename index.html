<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Assignment 6 &laquo; Data Visualization Dashboard&raquo;</title>
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    <link rel="stylesheet" href="main.css"/>
    <!--Feel free to add more CSS files as needed-->
    <script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>

</head>
<body>
    <div class="header">
        <h3>Assignment 6 &laquo; Data Visualization Dashboard &raquo;</h3>
    </div>

    <div class="center">
       <h2 id="value-range"></h2>
       <div class="row align-items-center">
        <div class="col-sm"><div id="slider-range"></div></div>
    </div>
</div>
<!--  We included a basic HTML structure for the 3 graphs here. Feel free to change this if you'd like  -->
<div class="row">
    <div class="col-lg-6">
        <div id="graph1"></div>
        <div id="graph2"></div><br/>
    </div>
    <div class="col-lg-6">
        <div id="graph3"></div>
    </div>
</div>
<div class="center">
<h2> Written Questions </h2>
</div>
<span class="written">
At the top of our dashboard is a slider that allows users to toggle which years to look at (ranging from the min to the max year in the dataset by release date). By default, this value goes from the max year (2020) to ten years before that (2010). However, a user can adjust that range to be anything they want. The range of years selected in this slider controls the data for all of our three graphs (i.e. if we select 2018-2020, all of our graphs will ONLY display data from those two years). Without more context on what our boss wants to see, it is difficult to determine if they only want information about modern movies or if they want to focus in on older films. This slider allows the user to deside for themselves and zoom-in and zoom-out of a time period as much as they desire. <br> <br>

Our dashboard also includes a bar chart that provides information about the number of titles for the top 10 genres on Netflix. This helps answer the question "what are the number of titles per genre on Netflix". One limitation of this approach is that it does not display the number of titles for every single genre. However, this is intentional. There are 41 unique genres in the dataset, and displaying information for all of them would be overwhelming, cluttered, and ultimately not useful. The most valuable insights most likely come from determining what the most popular genres are and what the distribution of number of titles are within those popular genres (rather than looking at the more fringe genres with few titles). Using this tool, we see that International movies, dramas, and comedies are the most popular genres.<br> <br>

Our dashboard also includes a bar chart indicating the average runtimes by year. In this case, I thought that just listing the 10 most popular years would not be sufficient. The user can use our slider (discussed above) to select what range of years to look at. Running into a similar issue as above, I realized that displaying 95 different years and 95 different corresponding bars was not a viable option. I decided that I wanted at most 10-11 "bars" in my bar chart at any time regardless of the number of years selected. I accomplished this by grouping years together depending on the number of years in the range selected. If I selected a 50 year period (1970-2020), for instance, I would have ranges of years be on my y-axis (1970-1974, 1975-1979, etc...) and average runtimes on my x-axis. If I selected a 100 year period, those ranges would be 8 years instead of four. If I only am looking at 2006-2008, then I would only have 3 bars (2006, 2007, 2008). This algorithmic, adaptive approach allows a user to zoom all the way out and see runtime trends over decades. They can then zoom into to specific years to see average runtimes just in those years rather than over ranges. This provides a user with a lot of flexibility to investigate the average runtime of movies by release year. Note that if there is no movie releases during a time period, that time period will not be included in the graph (even if it is within the date period selected using the slider). By doing this, a user can see that average runtimes have (somewhat unevenly) been declining since the 1960s. Something worth noting is that I intentionally chose to not use a scatter/line plot here, which is most common for time-series data. The reason I made this decision is because I thought that looking at averages over groups of years at a time may be the most interesting. Using bar charts smooths out the data a lot while still giving you the opportunity to zoom-in by adjusting the years slider. Both options would work, but I like my bar charts solution as outliers are less prominent when looking at a large range of years.<br> <br>

Lastly, our dashboard includes a force-directed network graph. This nodes in this flow chart represent actors and links between actors indicate that those actors have acted together at least one movie. When you hover over one of the nodes, it will darken and a tooltip will appear that shows the name of the actor that the node corresponds to. A challenge with this visualization is that there are over 27000 unique actors in the dataset and even more links between them. When a user selected a large time period, the size of the graph was too large to be useful and rendered too slowly to be user friendly. This led me to filter down on what actors I display. Initially, I tried just filtering out actors with less than 3 connections. This worked ok for relatively small date ranges. However, it did poorly on both extremes. In too small a range, it filtered too many actors out. In a large range, the graph was still way too big to render. This lead me to create a threshold of minimum number of connnections that was linearly related to the square root (roughly...this took some tweaking) of the number of unique actors in the selected time period. The number of actors in the selected time period is a good indicator for the size of the graph. Having an inverse square relationship makes sense, as for every actor we add there are an additional n more possible links that can exist from that actor. This adjustment allows a user to select any range and still get a graph that is interesting and doesn't crash the dashboard. The clusters that appear in the graph show you groups of popular actors. For some year ranges, you can see clusters arising from international films and studios and you can see which actors bridge the gap between these clusters. This graph provides interesting insight in that regard. Something else I tried was randomly removing actors rather than using a threshold. In its current form, the graph has a lot of very dense clusters that are a bit cluttered and don't provide a ton of new information. However, randomly deleting actors didn't do much to thin out these clusters and ended up compromising the usefuleness of the graph, so I decided against this method. Another insight that you can get from this graph is seeing which nodes have many different connections but have no edges. These nodes correspond to actors who have had worked with many other people, but none of the people they have worked with have also worked with a lot of different people. Lastly, the statistics calculation performed under this graph (the percentiles) is useful in helping a reader understand how many actors an average actor will work with. As it turns out, the majority of actors have relatively few co-stars, but a small minority have a lot (over 50). This statistic helps drive this insight. <br> <br>

D3 was useful in allowing for user interactivity to dynamically change the visualization. Without D3, I could perhaps use Python to generate graphs and incliude them as images in my dashboard. However, these would be static images that I would need to retrieve from a server or have saved in memory beforehand. I would not be able to instantly render a new graph by clicking a button or dragging a slider without making an API call to a server to retrieve updated graphs. Even then, I would lose the ability to have easily integratable tooltips, animations, and more if I adopted this approach. Additionally, D3 was useful in that it abstracted away a lot of the work that would be required in making graphs. Using pure HTML and Javascript without the D3 libraries would be extremely cumbersome. I would have to figure out every style, hardcode in every animation, manually determine sizing and layout, and do all of the math myself. For the flow graph, this would have been an absolute nightmare, as I would have to write my own simulator. Using D3 abstracted away these concerns and handled all of these details while still providing higher-level customization abilities. Lastly, D3 was helpful in providing a default aesthetic that I could build my visualization on top of. All of my graphs feel similar in aesthetic. This isn't just do to the coloring. The spacing is the same, the proportions match up, and it has an "official" feel to it. This comes from the built in styling that D3 has done under the hood. This makes it easy to quickly draw up an official looking graph in very little time. <br> <br>

Firstly, D3 has a serious learning curve. For some of the simpler graphs, it may be enough to just find a similar use-case online and adapt that code to your need. However, being able to customize the graph requires knowledge of the library, even for simple graphs. For more complicated graphs such as force directed network graphs, it is very difficult to build a useful version of this graph at all without understanding what parameters you need to edit. This takes time and effort to learn, and most likely constricts non-technical users or users unfamiliar with web technologies from using this library. Secondly, even for experienced and knowledgable users, it is not a very expedient method for creating a visualization for many use cases. If you just want to quickly create a bar chart for a powerpoint you are building, Excel or Python (Matplotlib) is most likely a better option. These options are lighter-weight and don't require me setting up a website to view. Lastly, D3 lacks some of the data processing infrastructure that Pandas or equivalents possess. Although D3 is a staple tool for data visualization (which often requires a lot of data processing and manipulation), it does not come in with the same data processing toolset that Pandas does. This means that you either need to do a lot of separate preprocessing of your data or manually write a lot of javascript code to accomplish tasks that you could do in a few lines of Python using Pandas or Numpy. Thus, if you need to do a lot of heavy data processing on the fly to create your graphs, D3 may be cumbersome to use.
</span>
<div class="center">
<h2> Accessible Data Questions </h2>
</div>
<span class="written">
Users with reasonably good vision will find this dashboard accessible. This includes users who are colorblind as the colors on the site are primarily just white and blue and were intentionally chosen to contrast well. Although the shade of the color in the bars in my bar graphs does correspond to the value it represents (and could be tough for colorblind users to pick out), this information is captured by the numbers directly to the side of the bars in the bar graph. Thus, even colorblind users will be able to find this dashboard accessible. Blind users, however, will have more difficulty. All of my axes are labeled and I have descriptive titles for the bar graphs. Additionally, I label the values of each bar in my bar graphs. Therefore, using a screenreader (as discussed in the Betterment article), a user could figure out what numbers the bar graph is describing. As suggested in that article, I also refrained from using hover overlays in the bar charts and instead included those values beside the bars (as screenreaders can struggle with hover overlays). The place where a screenreader would have significant issues is the flow chart. I use a hover text overlay to describe the actor name when hovering over a node. If I included the text next to every node, it would be a mess, so I elected to not do that. It would also be infeasible for a screenreader to read out every actor-actor connection, as the flow chart can be somewhat large and complex. An additional action that I could take is to include a description of what is roughly happening in the chart and what insights can be drawn (e.x. there are multiple clusters of actors. one seems to be primarily actors from the US. another primarily actors from India. A few actors have connections in both of these clusters, including ....). This would help users using screenreaders. Additionally, adding summaries to my bar charts would help screenreaders understand the larger takeways from the charts without having to keep track of all the numbers and labels and figure out those takeways on their own. <br><br>

In my design and implementation process, I initially wasn't thinking at all about accessibility and was just thinking about what would look cool and would convey the data to someone effectively (assuming they had good vision). This led me to favor complex tooling such as a slider for choosing dates, as this was a cool feauture and can provide a user with a lot of customizability. However, as discussed in the Beterment article, these are hard for visually impaired users to use. Additionally, the desire for cool and complicated-looking visualizations (as well as a desire for extra credit) led me to use the force-directed network graph. This graph is EXTREMELY difficult to interpret if you are a blind user. During my process, I think it would have been better to prioritize accessibility over the intricacy and "coolness" of my visualizations. Additional steps that I considered were to integrate dynamic summaries to my graphs. Overall, my dashboard is very dynamic in that a user can manipulate a single slider at the top and every graph changes and looks at different data. Attempting to write a single summary for the results of any graph is challenging therefore, as what the graph shows and what conclusions can be drawn heavily depends on the chosen date range. Thus, the main factor that prevented me from taking this step was difficulty and time, as this would require me writing summaries that would adapt depending on date selections.
</span>
<div class="center">
<h2> Extra Credit </h2>
</div>
<span class="written">
I have used a flow graph. I have also implemented a dynamic stats calculation. Under the flow graph, I have a label that provides information about how many costars has an actor worked with. As this calculation is dependent on the years selected using the slider, this calculation is dynamic. The information I provide is the percentiles using the d3 quantile function. This statistical calculation is useful as it gives an idea of how many costars your average actor has and what that distribution looks like. Note that these percentiles are NOT filtered down by our threshold for number of connections (which we do to render a clean graph).

Additionally, I do some interesting calculations (already described) in order to have my date-ranges dynamically render depending on the years selected (the interval sizes change depending on the years selection).
</span>
<!--Feel free to add more JavaScript files as needed-->
<script type="text/javascript" src="main.js"></script>
</body>
</html>
